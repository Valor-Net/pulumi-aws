name: Update ECS Service Image

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
      service_name:
        description: 'Service name'
        required: true
      stack:
        description: 'Stack name'
        required: true
      commit_sha:
        description: 'Commit SHA'
        required: true
      ecr_repository:
        description: 'ECR Repository'
        required: true
      ecr_nginx_repository:
        description: 'ECR Nginx Repository'
        required: false
      ecs_cluster:
        description: 'ECS Cluster'
        required: true
      pulumi_service_name:
        description: 'Pulumi Service Name'
        required: true

jobs:
  update-service:
    runs-on: ubuntu-latest
    environment: staging
    name: Run ECS update - ${{ github.event.inputs.stack }} - ${{ github.event.inputs.service_name }}
    permissions:
      contents: write
      id-token: write
      actions: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.INFRA_REPO_TOKEN }}
        persist-credentials: true 
      
    - name: Setup Pulumi
      uses: pulumi/actions@v4
      with:
        pulumi-version: ^3.0.0
        
    - name: Update Pulumi config and ECS Service
      env:
        PULUMI_CONFIG_PASSPHRASE: ""
        PULUMI_BACKEND_URL: ${{ secrets.PULUMI_BACKEND_URL }}
      run: |
        echo "üîÑ Atualizando imagem do servi√ßo: ${{ github.event.inputs.service_name }}"
        echo "üè∑Ô∏è Nova imagem tag: ${{ github.event.inputs.image_tag }}"
        
        # Definir vari√°veis
        CLUSTER_NAME="${{ github.event.inputs.ecs_cluster }}"
        SERVICE_NAME="${{ github.event.inputs.service_name }}"
        ECR_REPOSITORY="${{ github.event.inputs.ecr_repository }}"
        ECR_NGINX_REPOSITORY="${{ github.event.inputs.ecr_nginx_repository }}"
        IMAGE_TAG="${{ github.event.inputs.image_tag }}"
        STACK_NAME="${{ github.event.inputs.stack }}"
        
        # Construir as URIs completas das imagens
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        APP_IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
        
        echo "üê≥ Nova imagem da aplica√ß√£o: ${APP_IMAGE_URI}"
        
        # Verificar se existe imagem NGINX
        HAS_NGINX=false
        if [ -n "${ECR_NGINX_REPOSITORY}" ] && [ "${ECR_NGINX_REPOSITORY}" != "" ]; then
          HAS_NGINX=true
          NGINX_IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${ECR_NGINX_REPOSITORY}:${IMAGE_TAG}"
          echo "üåê Nova imagem do nginx: ${NGINX_IMAGE_URI}"
        else
          echo "‚ÑπÔ∏è Nenhuma imagem NGINX especificada - usando apenas aplica√ß√£o principal"
        fi
        
        # ========================================
        # 1. ATUALIZAR CONFIG DO PULUMI
        # ========================================
        echo "‚öôÔ∏è Atualizando configura√ß√£o do Pulumi..."
        
        # Selecionar stack
        pulumi stack select ${STACK_NAME}
        
        CONFIG_KEY="valornet-infra:${{github.event.inputs.pulumi_service_name}}.imageTag"
        
        echo "üìù Atualizando config: ${CONFIG_KEY} = ${IMAGE_TAG}"
        pulumi config set ${CONFIG_KEY} ${IMAGE_TAG}
        
        echo "‚úÖ Configura√ß√£o do Pulumi atualizada!"
        
        # ========================================
        # 2. ATUALIZAR ECS SERVICE
        # ========================================
        echo "üöÄ Atualizando servi√ßo ECS..."

        echo "cluster: ${{github.event.inputs.ecs_cluster}}"
        echo "service: ${{github.event.inputs.service_name}}"
        
        # Obter a task definition atual
        echo "üìã Obtendo task definition atual..."
        TASK_DEFINITION_ARN=$(aws ecs describe-services \
          --cluster ${{github.event.inputs.ecs_cluster}} \
          --services ${{github.event.inputs.service_name}} \
          --query 'services[0].taskDefinition' \
          --output text)
        
        echo "üìÑ Task Definition ARN: ${TASK_DEFINITION_ARN}"
        
        # Baixar a task definition atual
        aws ecs describe-task-definition \
          --task-definition ${TASK_DEFINITION_ARN} \
          --query 'taskDefinition' \
          --output json > task-definition.json
        
        # Atualizar as imagens na task definition
        echo "üîß Atualizando imagens na task definition..."
        
        # Mostrar containers atuais para debug
        echo "üìä Containers atuais:"
        jq -r '.containerDefinitions[] | "  - \(.name): \(.image)"' task-definition.json
        
        # L√≥gica condicional baseada na presen√ßa do NGINX
        if [ "${HAS_NGINX}" = true ]; then
          echo "üåê Modo com NGINX - Atualizando containers 'php' e 'web'"
          # Com NGINX: 'php' = aplica√ß√£o principal, 'web' = nginx
          jq --arg APP_IMAGE_URI "${APP_IMAGE_URI}" \
             --arg NGINX_IMAGE_URI "${NGINX_IMAGE_URI}" '
             .containerDefinitions = (.containerDefinitions | map(
               if .name == "php" then
                 .image = $APP_IMAGE_URI
               elif .name == "web" then
                 .image = $NGINX_IMAGE_URI
               else
                 .
               end
             )) |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
            task-definition.json > new-task-definition.json
        else
          echo "üîß Modo sem NGINX - Verificando containers dispon√≠veis..."
          
          # Verificar quais containers existem
          CONTAINERS=$(jq -r '.containerDefinitions[].name' task-definition.json)
          echo "üìã Containers encontrados: ${CONTAINERS}"
          
          # Determinar qual container atualizar
          if echo "${CONTAINERS}" | grep -q "worker"; then
            echo "üë∑ Container 'worker' encontrado - atualizando como principal"
            TARGET_CONTAINER="worker"
          elif echo "${CONTAINERS}" | grep -q "web"; then
            echo "üåê Container 'web' encontrado - atualizando como principal"
            TARGET_CONTAINER="web"
          else
            echo "‚ùå Erro: Nenhum container conhecido encontrado (worker/web)"
            exit 1
          fi
          
          # Atualizar apenas o container principal
          jq --arg APP_IMAGE_URI "${APP_IMAGE_URI}" \
             --arg TARGET_CONTAINER "${TARGET_CONTAINER}" '
             .containerDefinitions = (.containerDefinitions | map(
               if .name == $TARGET_CONTAINER then
                 .image = $APP_IMAGE_URI
               else
                 .
               end
             )) |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
            task-definition.json > new-task-definition.json
        fi
        
        echo "üìã Nova task definition (containers):"
        jq -r '.containerDefinitions[] | "  - \(.name): \(.image)"' new-task-definition.json
        
        # Registrar nova task definition
        echo "üìù Registrando nova task definition..."
        NEW_TASK_DEFINITION_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://new-task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "‚úÖ Nova task definition registrada: ${NEW_TASK_DEFINITION_ARN}"
        
        # Atualizar o servi√ßo com a nova task definition
        echo "üöÄ Atualizando servi√ßo..."
        aws ecs update-service \
          --cluster ${CLUSTER_NAME} \
          --service ${SERVICE_NAME} \
          --task-definition ${NEW_TASK_DEFINITION_ARN} \
          --force-new-deployment
        
        
        # ========================================
        # 3. REFRESH PULUMI STATE (SINCRONIZAR COM REALIDADE)
        # ========================================
        echo "üîÑ Executando Pulumi refresh para sincronizar estado..."
        echo "üìù Isso vai atualizar o state file com as mudan√ßas feitas diretamente no AWS"
        
        # Fazer refresh do estado para evitar drift
        if pulumi refresh --yes --stack "${STACK_NAME}"; then
          echo "‚úÖ Pulumi state atualizado com sucesso!"
          echo "üìä Estado sincronizado entre Pulumi e AWS"
        else
          echo "‚ö†Ô∏è Aviso: Falha no pulumi refresh, mas deployment foi conclu√≠do"
          echo "üí° Considere executar 'pulumi refresh' manualmente depois"
        fi

        # ========================================
        # 4. COMMIT MUDAN√áAS DO PULUMI
        # ========================================
        echo "üíæ Fazendo commit das mudan√ßas na configura√ß√£o..."
        
        # Verificar se h√° mudan√ßas
        if git diff --quiet; then
          echo "‚ÑπÔ∏è Nenhuma mudan√ßa para commit"
        else
          git config --global user.email "ci@valornet.com"
          git config --global user.name "CI/CD Bot"
          
          git add Pulumi.${STACK_NAME}.yaml
          
          # Commit message condicional
          if [ "${HAS_NGINX}" = true ]; then
            git commit -m "ü§ñ ci: update ${SERVICE_NAME} imageTag to ${IMAGE_TAG} (app + nginx)"
          else
            git commit -m "ü§ñ ci: update ${SERVICE_NAME} imageTag to ${IMAGE_TAG} (app only)"
          fi
          
          # Push mudan√ßas
          git push origin main
          
          echo "‚úÖ Configura√ß√£o commitada e enviada!"
        fi
        
        echo "üéâ Processo conclu√≠do com sucesso!"
        echo "üìä Resumo:"
        echo "  - Config Pulumi: ‚úÖ Atualizada"
        echo "  - ECS Service: ‚úÖ Atualizado"
        echo "  - Servi√ßo: ${SERVICE_NAME}"
        echo "  - Nova tag: ${IMAGE_TAG}"
        echo "  - Imagem da aplica√ß√£o: ${APP_IMAGE_URI}"
        
        if [ "${HAS_NGINX}" = true ]; then
          echo "  - Imagem do nginx: ${NGINX_IMAGE_URI}"
          echo "  - Containers atualizados: php, web"
        else
          echo "  - Modo: Sem NGINX"
          echo "  - Container atualizado: ${TARGET_CONTAINER:-'detectado automaticamente'}"
        fi